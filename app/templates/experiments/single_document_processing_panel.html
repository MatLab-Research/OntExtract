<!-- Single Document Processing Panel for Experiments -->
{% from "macros/processing_badges.html" import operation_badge, OPERATION_ORDER %}
<style>
/* Fix for sticky navigation interfering with Bootstrap modal */
.modal-open .navigation-card {
    position: static !important;
}

/* Ensure modal content is interactive */
.modal {
    pointer-events: auto;
}

.modal-content {
    pointer-events: auto;
}

.modal-body {
    pointer-events: auto;
}

.modal-body * {
    pointer-events: auto;
}
</style>
<div class="card">
    <div class="card-header">
        <h6 class="mb-0">
            <i class="fas fa-cogs me-2"></i>Processing Operations
        </h6>
    </div>
    <div class="card-body">
        <!-- Current Processing Status -->
        <div class="mb-3">
            <div class="processing-status" id="processing-status-{{ experiment_document.id }}">
                {% if processing_operations %}
                    {# Render operations in standard order: cleanup, segmentation, embeddings, entities, temporal, definitions #}
                    {% set op_order = ['cleanup', 'segmentation', 'embeddings', 'entities', 'temporal', 'definitions'] %}
                    {% for op_type in op_order %}
                        {% for op in processing_operations %}
                            {% if op.processing_type == op_type %}
                                {{ operation_badge(op.processing_type, op.processing_method) }}
                            {% endif %}
                        {% endfor %}
                    {% endfor %}
                    {# Render any operations not in standard order #}
                    {% for op in processing_operations %}
                        {% if op.processing_type not in op_order %}
                            {{ operation_badge(op.processing_type, op.processing_method) }}
                        {% endif %}
                    {% endfor %}
                {% else %}
                    <small class="text-muted">No manual processing applied</small>
                {% endif %}
            </div>
        </div>

        <!-- Processing Results Status -->
        <div id="processing-status-results" class="mt-3" style="display: none;">
            <hr class="my-3">
            <div id="processing-status-content">
                <!-- Results will be inserted here -->
            </div>
        </div>
    </div>
</div>

<!-- Document Processing Results -->
<div class="card mt-3">
    <div class="card-header">
        <h6 class="mb-0">
            <i class="fas fa-file-alt me-2"></i>Processing Results
        </h6>
    </div>
    <div class="card-body">
        <p class="small text-muted mb-3">View extraction results for this document</p>
        <div class="d-grid gap-2">
            {# Check for segments #}
            {% set has_segments = processing_operations|selectattr('processing_type', 'equalto', 'segmentation')|selectattr('status', 'equalto', 'completed')|list %}
            <a href="/process/document/{{ document.uuid }}/results/segments"
               id="result-link-segments"
               class="btn btn-sm {% if has_segments %}btn-warning{% else %}btn-outline-secondary disabled{% endif %}"
               {% if not has_segments %}aria-disabled="true"{% endif %}
               target="_blank">
                <i class="fas fa-cut {% if has_segments %}text-dark{% else %}text-warning{% endif %} me-1"></i>Segments
            </a>

            {# Check for embeddings #}
            {% set has_embeddings = llm_operations.get('period_aware_embedding', {}).get('status') == 'executed' or
                                    processing_operations|selectattr('processing_type', 'equalto', 'embeddings')|selectattr('status', 'equalto', 'completed')|list %}
            {% set emb_count = llm_operations.get('period_aware_embedding', {}).get('count', 0) %}
            <a href="/process/document/{{ document.uuid }}/results/embeddings"
               id="result-link-embeddings"
               class="btn btn-sm {% if has_embeddings %}btn-info{% else %}btn-outline-secondary disabled{% endif %}"
               {% if not has_embeddings %}aria-disabled="true"{% endif %}
               target="_blank">
                <i class="fas fa-vector-square {% if has_embeddings %}text-white{% else %}text-info{% endif %} me-1"></i>Embeddings
                {% if has_embeddings and emb_count %}<span class="badge bg-light text-dark ms-1">{{ emb_count }}</span>{% endif %}
            </a>

            {# Check for entities #}
            {% set has_entities = llm_operations.get('extract_entities_spacy', {}).get('status') == 'executed' or
                                  processing_operations|selectattr('processing_type', 'equalto', 'entities')|selectattr('status', 'equalto', 'completed')|list %}
            {% set ent_count = llm_operations.get('extract_entities_spacy', {}).get('count', 0) %}
            <a href="/process/document/{{ document.uuid }}/results/entities"
               id="result-link-entities"
               class="btn btn-sm {% if has_entities %}btn-success{% else %}btn-outline-secondary disabled{% endif %}"
               {% if not has_entities %}aria-disabled="true"{% endif %}
               target="_blank">
                <i class="fas fa-tags {% if has_entities %}text-white{% else %}text-success{% endif %} me-1"></i>Entities
                {% if has_entities and ent_count %}<span class="badge bg-light text-dark ms-1">{{ ent_count }}</span>{% endif %}
            </a>

            {# Check for definitions - from LLM orchestration or manual processing #}
            {% set has_definitions = llm_operations.get('extract_definitions', {}).get('status') == 'executed' or
                                     processing_operations|selectattr('processing_type', 'equalto', 'definitions')|selectattr('status', 'equalto', 'completed')|list %}
            {% set def_count = llm_operations.get('extract_definitions', {}).get('count', 0) %}
            <a href="/process/document/{{ document.uuid }}/results/definitions"
               id="result-link-definitions"
               class="btn btn-sm {% if has_definitions %}btn-primary{% else %}btn-outline-secondary disabled{% endif %}"
               {% if not has_definitions %}aria-disabled="true"{% endif %}
               target="_blank">
                <i class="fas fa-book {% if has_definitions %}text-white{% else %}text-primary{% endif %} me-1"></i>Definitions
                {% if has_definitions and def_count %}<span class="badge bg-light text-dark ms-1">{{ def_count }}</span>{% endif %}
            </a>

            {# Check for temporal markers #}
            {% set has_temporal = llm_operations.get('extract_temporal', {}).get('status') == 'executed' or
                                  processing_operations|selectattr('processing_type', 'equalto', 'temporal')|selectattr('status', 'equalto', 'completed')|list %}
            {% set temp_count = llm_operations.get('extract_temporal', {}).get('count', 0) %}
            <a href="/process/document/{{ document.uuid }}/results/temporal"
               id="result-link-temporal"
               class="btn btn-sm {% if has_temporal %}btn-secondary{% else %}btn-outline-secondary disabled{% endif %}"
               {% if not has_temporal %}aria-disabled="true"{% endif %}
               target="_blank">
                <i class="fas fa-clock text-muted me-1"></i>Temporal
                {% if has_temporal and temp_count %}<span class="badge bg-light text-dark ms-1">{{ temp_count }}</span>{% endif %}
            </a>
        </div>
    </div>
</div>

<!-- Bootstrap Processing Modal -->
<div class="modal fade" id="processingModal" tabindex="-1" aria-labelledby="processingModalTitle" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="processingModalTitle">Process Document</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body" id="processingModalBody">
                <!-- Content will be populated by JavaScript -->
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                {% if current_user.is_authenticated %}
                <button type="button" class="btn btn-primary" id="startProcessingBtn" onclick="startProcessing()">
                    Start Processing
                </button>
                {% else %}
                <span class="text-muted small">Login required to start processing</span>
                {% endif %}
            </div>
        </div>
    </div>
</div>

<script>
let currentProcessingConfig = {};

function loadProcessingStatus() {
    // Load processing status for this document using document UUID
    const documentUuid = '{{ document.uuid }}';
    fetch(`/process/document/${documentUuid}/processing-jobs`)
        .then(response => response.json())
        .then(data => {
            updateProcessingStatusDisplay({{ experiment_document.id }}, data);
        })
        .catch(error => {
            console.error('Error loading processing status:', error);
            document.getElementById('processing-status-{{ experiment_document.id }}').innerHTML =
                '<span class="badge bg-danger">Error</span>';
        });
}

function updateProcessingStatusDisplay(expDocId, statusData) {
    const statusContainer = document.getElementById(`processing-status-${expDocId}`);
    let html = '';

    if (statusData.processing_operations && statusData.processing_operations.length > 0) {
        statusData.processing_operations.forEach(op => {
            let badgeClass = 'bg-secondary';
            let icon = '';
            let linkIcon = '';

            // Format display name
            const displayName = formatProcessingTypeName(op.processing_type);
            const methodName = op.processing_method || 'default';

            // Add count indicator if multiple runs exist
            const countIndicator = op.run_count > 1 ? ` (${op.run_count}Ã—)` : '';
            const historyTitle = op.has_history ? `Latest of ${op.run_count} runs, click to view history` : 'View results';

            switch(op.status) {
                case 'completed':
                    badgeClass = 'bg-success';
                    icon = '<i class="fas fa-check me-1"></i>';
                    if (op.has_history) {
                        linkIcon = '<a href="#" onclick="viewProcessingHistory(event, \'' + op.processing_type + '\', \'' + op.processing_method + '\', ' + JSON.stringify(op.all_job_ids) + ')" class="text-white ms-1" title="' + historyTitle + '"><i class="fas fa-history"></i></a>';
                    } else {
                        linkIcon = '<a href="#" onclick="viewProcessingResults(event, \'' + op.processing_type + '\', \'' + op.processing_method + '\', ' + op.id + ')" class="text-white ms-1" title="' + historyTitle + '"><i class="fas fa-external-link-alt"></i></a>';
                    }
                    break;
                case 'running':
                    badgeClass = 'bg-warning';
                    icon = '<i class="fas fa-spinner fa-spin me-1"></i>';
                    break;
                case 'failed':
                    badgeClass = 'bg-danger';
                    icon = '<i class="fas fa-times me-1"></i>';
                    linkIcon = '<a href="#" onclick="viewProcessingResults(event, \'' + op.processing_type + '\', \'' + op.processing_method + '\', ' + op.id + ')" class="text-white ms-1" title="View error details"><i class="fas fa-exclamation-circle"></i></a>';
                    break;
                case 'pending':
                    badgeClass = 'bg-info';
                    icon = '<i class="fas fa-clock me-1"></i>';
                    break;
            }

            html += `<span class="badge ${badgeClass} me-1 mb-1">
                ${icon}${displayName}: ${methodName}${countIndicator}${linkIcon}
            </span>`;
        });
    } else {
        html = '<small class="text-muted">No processing applied</small>';
    }

    statusContainer.innerHTML = html;

    // Update result link buttons based on available processing types
    updateResultLinks(statusData.processing_operations || []);
}

function updateResultLinks(operations) {
    // Map processing types to button IDs and short names
    const linkMap = {
        'generate_embeddings': 'embeddings',
        'segment_document': 'segments',
        'extract_entities': 'entities'
    };

    // Find which processing types have completed operations
    const completedTypes = new Set();
    operations.forEach(op => {
        if (op.status === 'completed' && linkMap[op.processing_type]) {
            completedTypes.add(linkMap[op.processing_type]);
        }
    });

    // Update each button
    Object.values(linkMap).forEach(linkType => {
        const button = document.getElementById(`result-link-${linkType}`);
        if (button) {
            if (completedTypes.has(linkType)) {
                // Enable button
                button.classList.remove('disabled');
                button.style.pointerEvents = 'auto';
                button.style.opacity = '1';
            } else {
                // Keep button disabled
                button.classList.add('disabled');
                button.style.pointerEvents = 'none';
                button.style.opacity = '0.5';
            }
        }
    });
}

function formatProcessingTypeName(jobType) {
    const names = {
        'generate_embeddings': 'Embeddings',
        'segment_document': 'Segmentation',
        'extract_entities': 'Entities',
        'clean_text': 'Text Cleanup'
    };
    return names[jobType] || jobType;
}

function viewProcessingResults(event, processingType, method, operationId) {
    event.preventDefault();

    // Build URL based on processing type
    const documentUuid = '{{ document.uuid }}';
    let url = '';

    // Map job types to result pages
    if (processingType === 'generate_embeddings') {
        url = `/process/document/${documentUuid}/results/embeddings`;
    } else if (processingType === 'segment_document') {
        url = `/process/document/${documentUuid}/results/segments`;
    } else if (processingType === 'extract_entities') {
        url = `/process/document/${documentUuid}/results/entities`;
    } else if (processingType === 'definitions') {
        url = `/process/document/${documentUuid}/results/definitions`;
    } else if (processingType === 'temporal') {
        url = `/process/document/${documentUuid}/results/temporal`;
    } else {
        // Default: go to provenance timeline
        url = `/provenance/timeline?document_uuid=${documentUuid}`;
    }

    // Open in new tab
    window.open(url, '_blank');
}

function viewProcessingHistory(event, processingType, method, jobIdsJson) {
    event.preventDefault();

    const documentUuid = '{{ document.uuid }}';
    const displayName = formatProcessingTypeName(processingType);

    // For now, open the provenance timeline filtered to this document
    // In the future, could show a modal with job history
    const url = `/provenance/timeline?document_uuid=${documentUuid}`;

    window.open(url, '_blank');
}

function showProcessingModal(expDocId, processingType) {
    currentProcessingConfig = {
        experiment_document_id: expDocId,
        processing_type: processingType
    };

    const modalElement = document.getElementById('processingModal');
    const title = document.getElementById('processingModalTitle');
    const body = document.getElementById('processingModalBody');

    title.textContent = `${processingType.charAt(0).toUpperCase() + processingType.slice(1)} Processing`;

    // Show different options based on processing type
    let html = '';

    if (processingType === 'embeddings') {
        html = `
            <p>Choose an embedding method:</p>
            <div class="form-check mb-2">
                <input class="form-check-input" type="radio" name="method" value="local" id="method-local" checked>
                <label class="form-check-label" for="method-local" style="cursor: pointer;">
                    <strong>Local</strong> (sentence-transformers)<br>
                    <small class="text-muted">Fast, free, 384 dimensions</small>
                </label>
            </div>
            <div class="form-check mb-2">
                <input class="form-check-input" type="radio" name="method" value="openai" id="method-openai">
                <label class="form-check-label" for="method-openai" style="cursor: pointer;">
                    <strong>OpenAI</strong> (text-embedding-3-large)<br>
                    <small class="text-muted">High quality, 1536 dimensions, requires API key</small>
                </label>
            </div>
        `;
    } else if (processingType === 'segmentation') {
        html = `
            <p>Choose a segmentation method:</p>
            <div class="form-check mb-3">
                <input class="form-check-input" type="radio" name="method" value="paragraph" id="method-paragraph" checked>
                <label class="form-check-label" for="method-paragraph" style="cursor: pointer;">
                    <strong>Paragraph-based</strong><br>
                    <small class="text-muted"><i class="fas fa-cogs me-1"></i>NLTK-enhanced regex patterns</small><br>
                    <small class="text-success"><i class="fas fa-check me-1"></i>Preserves document structure, good for academic texts</small>
                </label>
            </div>
            <div class="form-check mb-3">
                <input class="form-check-input" type="radio" name="method" value="sentence" id="method-sentence">
                <label class="form-check-label" for="method-sentence" style="cursor: pointer;">
                    <strong>Sentence-based</strong><br>
                    <small class="text-muted"><i class="fas fa-microchip me-1"></i>NLTK Punkt Tokenizer</small><br>
                    <small class="text-success"><i class="fas fa-check me-1"></i>Handles abbreviations, fine-grained analysis</small>
                </label>
            </div>
            <div class="form-check mb-3">
                <input class="form-check-input" type="radio" name="method" value="semantic" id="method-semantic">
                <label class="form-check-label" for="method-semantic" style="cursor: pointer;">
                    <strong>Semantic chunking</strong><br>
                    <small class="text-muted"><i class="fas fa-brain me-1"></i>spaCy NLP + NLTK Punkt</small><br>
                    <small class="text-success"><i class="fas fa-check me-1"></i>Entity-aware, context-preserving chunks</small>
                </label>
            </div>
        `;
    } else if (processingType === 'entities') {
        html = `
            <p>Choose an entity extraction method:</p>
            <div class="form-check mb-2">
                <input class="form-check-input" type="radio" name="method" value="spacy" id="method-spacy" checked>
                <label class="form-check-label" for="method-spacy" style="cursor: pointer;">
                    <strong>spaCy NER</strong><br>
                    <small class="text-muted">Fast, reliable named entity recognition</small>
                </label>
            </div>
            <div class="form-check mb-2">
                <input class="form-check-input" type="radio" name="method" value="nltk" id="method-nltk">
                <label class="form-check-label" for="method-nltk" style="cursor: pointer;">
                    <strong>NLTK-based</strong><br>
                    <small class="text-muted">Traditional NLP toolkit approach</small>
                </label>
            </div>
            <div class="form-check mb-2">
                <input class="form-check-input" type="radio" name="method" value="llm" id="method-llm">
                <label class="form-check-label" for="method-llm" style="cursor: pointer;">
                    <strong>LangExtract + Gemini</strong><br>
                    <small class="text-muted">Google Gemini-powered extraction with character-level positioning</small>
                </label>
            </div>
        `;
    }

    body.innerHTML = html;

    // Add debugging event listeners after content is inserted
    setTimeout(() => {
        const radioButtons = modalElement.querySelectorAll('input[type="radio"]');
        console.log('Found radio buttons in modal:', radioButtons.length);

        radioButtons.forEach((radio, index) => {
            console.log(`Radio ${index}: id=${radio.id}, name=${radio.name}, value=${radio.value}`);

            // Test if click works
            radio.addEventListener('click', (e) => {
                console.log(`Radio clicked: ${radio.value}`);
            });
        });
    }, 100);

    // Simple Bootstrap modal show
    const bsModal = new bootstrap.Modal(modalElement);
    bsModal.show();

    console.log('Bootstrap modal shown');
}

function startProcessing() {
    const selectedMethod = document.querySelector('input[name="method"]:checked');
    if (!selectedMethod) {
        alert('Please select a processing method');
        return;
    }

    currentProcessingConfig.processing_method = selectedMethod.value;

    // Disable the button and show loading state
    const btn = document.getElementById('startProcessingBtn');
    btn.disabled = true;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Starting...';

    // Make API call to start processing
    fetch('/experiments/api/experiment-processing/start', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(currentProcessingConfig)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Close modal and refresh status
            const modal = bootstrap.Modal.getInstance(document.getElementById('processingModal'));
            if (modal) {
                modal.hide();
            }
            setTimeout(() => {
                // loadProcessingStatus(); // DISABLED - processing routes not available
                // Refresh the page to show updated processing operations
                window.location.reload();
            }, 1000);

            // Show success message
            showAlert('Processing started successfully!', 'success');
        } else {
            showAlert('Error starting processing: ' + (data.error || 'Unknown error'), 'danger');
        }
    })
    .catch(error => {
        console.error('Error:', error);
        showAlert('Error starting processing', 'danger');
    })
    .finally(() => {
        // Re-enable button
        btn.disabled = false;
        btn.innerHTML = 'Start Processing';
    });
}

function showAlert(message, type) {
    const alertHtml = `
        <div class="alert alert-${type} alert-dismissible fade show" role="alert">
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        </div>
    `;

    // Insert at top of page
    const container = document.querySelector('.container-fluid');
    container.insertAdjacentHTML('afterbegin', alertHtml);

    // Auto-dismiss after 5 seconds
    setTimeout(() => {
        const alert = container.querySelector('.alert');
        if (alert) {
            new bootstrap.Alert(alert).close();
        }
    }, 5000);
}

// Load processing status when page loads
// TEMPORARILY DISABLED - Processing routes disabled due to circular import
document.addEventListener('DOMContentLoaded', function() {
    // loadProcessingStatus();

    // Refresh status every 30 seconds
    // setInterval(loadProcessingStatus, 30000);
});
</script>