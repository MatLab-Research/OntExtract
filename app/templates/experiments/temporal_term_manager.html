{% extends "base.html" %}

{% block title %}Track Terms Over Time - {{ experiment.name }} - OntExtract{% endblock %}

{% block content %}
<style>
    .term-card {
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        background: white;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        transition: box-shadow 0.3s ease;
    }
    
    .term-card:hover {
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    
    .term-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 2px solid #f0f0f0;
    }
    
    .term-title {
        font-size: 1.5rem;
        font-weight: 600;
        color: #2c3e50;
    }
    
    .term-actions {
        display: flex;
        gap: 10px;
    }
    
    .timeline-container {
        display: flex;
        overflow-x: auto;
        gap: 15px;
        padding: 10px 0;
        margin-top: 15px;
    }
    
    .time-period-column {
        min-width: 200px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 6px;
        border-top: 4px solid;
        position: relative;
    }
    
    /* Color gradient for time periods */
    .time-period-column:nth-child(1) { border-top-color: #007bff; background: linear-gradient(180deg, #e7f3ff 0%, #f8f9fa 100%); }
    .time-period-column:nth-child(2) { border-top-color: #0056b3; background: linear-gradient(180deg, #d1e7ff 0%, #f8f9fa 100%); }
    .time-period-column:nth-child(3) { border-top-color: #004085; background: linear-gradient(180deg, #b8daff 0%, #f8f9fa 100%); }
    .time-period-column:nth-child(4) { border-top-color: #002752; background: linear-gradient(180deg, #9ec5fe 0%, #f8f9fa 100%); }
    .time-period-column:nth-child(5) { border-top-color: #001a3d; background: linear-gradient(180deg, #84b6fc 0%, #f8f9fa 100%); }
    .time-period-column:nth-child(6) { border-top-color: #000d1f; background: linear-gradient(180deg, #6ea8fe 0%, #f8f9fa 100%); }
    
    .period-label {
        font-weight: 700;
        color: #495057;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 1.1rem;
    }
    
    .period-year {
        background: white;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 0.9rem;
    }
    
    .definition-content {
        padding: 10px;
        background: white;
        border-radius: 4px;
        line-height: 1.6;
        color: #212529;
        margin-bottom: 10px;
        min-height: 100px;
    }
    
    .definition-text {
        color: #212529;
        font-size: 0.95rem;
    }
    
    .definition-source {
        font-size: 0.85rem;
        color: #6c757d;
        font-style: italic;
        margin-top: 5px;
    }
    
    .frequency-indicator {
        margin-top: 10px;
        padding: 8px;
        background: white;
        border-radius: 4px;
        border-left: 3px solid #28a745;
    }
    
    .frequency-bar {
        height: 20px;
        background: linear-gradient(90deg, #28a745 0%, #20c997 100%);
        border-radius: 3px;
        margin-top: 5px;
        transition: width 0.3s ease;
    }
    
    .context-changes {
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid #dee2e6;
    }
    
    .context-badge {
        display: inline-block;
        padding: 3px 8px;
        background: #fff3cd;
        color: #856404;
        border-radius: 4px;
        font-size: 0.85rem;
        margin-right: 5px;
        margin-bottom: 5px;
    }
    
    .definition-placeholder {
        padding: 10px;
        background: white;
        border: 1px dashed #dee2e6;
        border-radius: 4px;
        color: #6c757d;
        font-style: italic;
    }
    
    .loading-spinner {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid #f3f3f3;
        border-top: 2px solid #007bff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .timeline-arrow {
        position: absolute;
        right: -7px;
        top: 50%;
        transform: translateY(-50%);
        color: #6c757d;
        font-size: 1.2rem;
    }
    
    .evolution-indicator {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.75rem;
        font-weight: 600;
        margin-left: 5px;
    }
    
    .evolution-new { background: #d4edda; color: #155724; }
    .evolution-changed { background: #fff3cd; color: #856404; }
    .evolution-stable { background: #d1ecf1; color: #0c5460; }
    .evolution-declining { background: #f8d7da; color: #721c24; }

    /* Period Cards - Bootstrap Card Design */
    .period-card {
        background: white;
        border: 1px solid #dee2e6;
        border-left: 4px solid;
        border-radius: 0.375rem;
        padding: 0;
        margin-bottom: 16px;
        min-width: 250px;
        max-width: 300px;
        min-height: 200px;
        transition: all 0.2s ease;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        display: flex;
        flex-direction: column;
    }

    .period-card:hover {
        box-shadow: 0 4px 6px rgba(0,0,0,0.15);
        transform: translateY(-2px);
    }

    .period-card.auto-generated {
        border-left-color: #0d6efd;
    }

    .period-card.manual {
        border-left-color: #6c757d;
    }

    .period-card.oed {
        border-left-color: #198754;
    }

    /* Period boundary markers - special styling */
    .period-card[data-boundary="start"] {
        border-left-color: #6f42c1;
        border-left-width: 6px;
        position: relative;
    }

    .period-card[data-boundary="end"] {
        border-left-color: #6f42c1;
        border-left-width: 6px;
        position: relative;
    }

    .period-card[data-boundary="start"]::after {
        content: "▶";
        position: absolute;
        right: -12px;
        top: 50%;
        transform: translateY(-50%);
        color: #28a745;
        font-size: 1.2rem;
        z-index: 1;
    }

    .period-card[data-boundary="end"]::before {
        content: "◀";
        position: absolute;
        left: -12px;
        top: 50%;
        transform: translateY(-50%);
        color: #dc3545;
        font-size: 1.2rem;
        z-index: 1;
    }

    .period-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        background-color: #f8f9fa;
        border-bottom: 1px solid #dee2e6;
    }

    .period-year {
        font-size: 1.25rem;
        font-weight: 700;
        color: #212529;
    }

    .period-source-badge {
        font-size: 0.7rem;
        padding: 4px 8px;
        border-radius: 0.25rem;
        font-weight: 600;
        text-transform: uppercase;
    }

    .period-source-badge.auto-generated {
        background: #0d6efd;
        color: white;
    }

    .period-source-badge.manual {
        background: #6c757d;
        color: white;
    }

    .period-source-badge.oed {
        background: #198754;
        color: white;
    }

    .period-documents {
        padding: 12px 16px;
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
    }

    .period-documents-title {
        font-size: 0.75rem;
        color: #6c757d;
        margin-bottom: 8px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .period-document-item {
        font-size: 0.875rem;
        color: #495057;
        padding: 6px 0;
        display: flex;
        align-items: flex-start;
        gap: 8px;
        line-height: 1.4;
    }

    .period-document-item i {
        color: #adb5bd;
        font-size: 0.5rem;
        margin-top: 6px;
    }

    .period-document-link {
        color: #495057;
        text-decoration: none;
        transition: color 0.2s ease;
    }

    .period-document-link:hover {
        color: #0d6efd;
        text-decoration: underline;
    }

    .period-card-footer {
        display: flex;
        justify-content: flex-end;
        padding: 12px 16px;
        background-color: #f8f9fa;
        border-top: 1px solid #dee2e6;
    }

    .period-remove {
        background: transparent;
        border: none;
        color: #dc3545;
        cursor: pointer;
        padding: 4px 8px;
        font-size: 0.875rem;
        border-radius: 0.25rem;
        transition: all 0.2s ease;
        font-weight: 500;
    }

    .period-remove:hover {
        background: #dc3545;
        color: white;
    }

    .period-add-btn {
        background: white;
        border: 2px dashed #dee2e6;
        border-radius: 0.375rem;
        padding: 32px 24px;
        margin-bottom: 16px;
        min-width: 250px;
        max-width: 300px;
        color: #6c757d;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: center;
        font-weight: 600;
    }

    .period-add-btn:hover {
        background: #f8f9fa;
        border-color: #adb5bd;
        color: #495057;
    }

    .period-add-btn i {
        display: block;
        font-size: 2rem;
        margin-bottom: 8px;
        color: #adb5bd;
    }

    .period-add-btn:hover i {
        color: #6c757d;
    }

    /* Semantic Event Cards - For tracking temporal transitions */
    .semantic-event-card {
        background: white;
        border: 1px solid #dee2e6;
        border-left: 4px solid;
        border-radius: 0.375rem;
        padding: 0;
        margin-bottom: 16px;
        min-width: 250px;
        max-width: 300px;
        min-height: 220px;
        transition: all 0.2s ease;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        display: flex;
        flex-direction: column;
    }

    .semantic-event-card:hover {
        box-shadow: 0 4px 6px rgba(0,0,0,0.15);
        transform: translateY(-2px);
    }

    /* Event type colors */
    .semantic-event-card.inflection_point {
        border-left-color: #6f42c1;  /* Purple - major semantic shift */
    }

    .semantic-event-card.stable_polysemy {
        border-left-color: #20c997;  /* Teal - multiple stable meanings */
    }

    .semantic-event-card.domain_network {
        border-left-color: #fd7e14;  /* Orange - domain-specific usage */
    }

    .semantic-event-card.semantic_shift {
        border-left-color: #d63384;  /* Pink - gradual meaning change */
    }

    .semantic-event-card.emergence {
        border-left-color: #198754;  /* Green - new meaning emerging */
    }

    .semantic-event-card.decline {
        border-left-color: #dc3545;  /* Red - meaning fading */
    }

    .semantic-event-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-bottom: 1px solid #dee2e6;
    }

    .semantic-event-type {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }

    .semantic-event-type-label {
        font-size: 0.7rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: #6c757d;
    }

    .semantic-event-type-name {
        font-size: 0.95rem;
        font-weight: 600;
        color: #212529;
    }

    .semantic-event-date-range {
        font-size: 0.875rem;
        font-weight: 700;
        color: #495057;
    }

    .semantic-event-body {
        padding: 12px 16px;
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
    }

    .semantic-event-description {
        font-size: 0.875rem;
        color: #495057;
        line-height: 1.5;
        margin-bottom: 10px;
    }

    .semantic-event-related-docs {
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px dashed #dee2e6;
    }

    .semantic-event-related-docs-title {
        font-size: 0.7rem;
        color: #6c757d;
        margin-bottom: 6px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .semantic-event-doc-item {
        font-size: 0.8rem;
        color: #495057;
        padding: 4px 0;
        display: flex;
        align-items: flex-start;
        gap: 6px;
    }

    .semantic-event-doc-item i {
        color: #adb5bd;
        font-size: 0.4rem;
        margin-top: 5px;
    }

    .semantic-event-footer {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        padding: 12px 16px;
        background-color: #f8f9fa;
        border-top: 1px solid #dee2e6;
    }

    .semantic-event-edit,
    .semantic-event-remove {
        background: transparent;
        border: none;
        cursor: pointer;
        padding: 4px 8px;
        font-size: 0.875rem;
        border-radius: 0.25rem;
        transition: all 0.2s ease;
        font-weight: 500;
    }

    .semantic-event-edit {
        color: #0d6efd;
    }

    .semantic-event-edit:hover {
        background: #0d6efd;
        color: white;
    }

    .semantic-event-remove {
        color: #dc3545;
    }

    .semantic-event-remove:hover {
        background: #dc3545;
        color: white;
    }

    .semantic-event-add-btn {
        background: white;
        border: 2px dashed #dee2e6;
        border-radius: 0.375rem;
        padding: 32px 24px;
        margin-bottom: 16px;
        min-width: 250px;
        max-width: 300px;
        color: #6c757d;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: center;
        font-weight: 600;
    }

    .semantic-event-add-btn:hover {
        background: #f8f9fa;
        border-color: #6f42c1;
        color: #6f42c1;
    }

    .semantic-event-add-btn i {
        display: block;
        font-size: 2rem;
        margin-bottom: 8px;
        color: #adb5bd;
    }

    .semantic-event-add-btn:hover i {
        color: #6f42c1;
    }

    /* Expanded timeline view */
    .timeline-expanded {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 1050;
        background: white;
        overflow-y: auto;
        padding: 20px;
    }

    .timeline-expanded .card {
        margin: 0;
        border: none;
        box-shadow: none;
    }

    .timeline-expand-btn {
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .timeline-expand-btn:hover {
        color: #0d6efd;
    }
</style>

<div class="container-fluid px-4">
    <!-- Header -->
    <div class="row mt-4">
        <div class="col-12">
            <!-- Row 1: Buttons -->
            <div class="d-flex justify-content-start align-items-center mb-3">
                <a href="{{ url_for('experiments.view', experiment_id=experiment.id) }}"
                   class="btn btn-outline-secondary me-2">
                    <i class="fas fa-arrow-left"></i> Back to Experiment
                </a>
                {% if terms and terms|length > 0 %}
                <button class="btn btn-outline-primary me-2" onclick="saveTerms()">
                    <i class="fas fa-save"></i> Save Configuration
                </button>
                {% endif %}
                {% if semantic_events and semantic_events|length > 0 %}
                <a href="{{ url_for('experiments.timeline_view', experiment_id=experiment.id) }}"
                   class="btn btn-outline-secondary me-2">
                    <i class="fas fa-stream"></i> View Timeline
                </a>
                {% endif %}
                <a href="{{ url_for('experiments.document_pipeline', experiment_id=experiment.id) }}"
                   class="btn btn-success">
                    <i class="fas fa-robot"></i> LLM Analyze
                </a>
            </div>

            <!-- Row 2: Title -->
            <div class="mb-2">
                <h2>{{ experiment.name }}</h2>
            </div>

            <!-- Row 3: Metadata -->
            <div class="mb-4">
                <p class="text-muted mb-0">
                    <i class="fas fa-clock"></i> Temporal Evolution Experiment
                    <span class="ms-3">
                        <i class="fas fa-calendar-alt"></i>
                        {{ start_year }} - {{ end_year }}
                        <span class="badge bg-secondary ms-1">{{ time_periods|length }} periods</span>
                    </span>
                    <span class="ms-3">
                        <i class="fas fa-tags"></i>
                        <span id="term-count">{{ terms|length }}</span> Terms
                    </span>
                </p>
            </div>
        </div>
    </div>

    <!-- Timeline: Periods & Semantic Events -->
    <div class="row mb-3" id="timeline-section">
        <div class="col-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0"><i class="fas fa-layer-group"></i> Temporal Elements</h5>
                    <div class="d-flex align-items-center gap-2">
                        <span class="badge bg-secondary">{{ semantic_events|length if semantic_events else 0 }} events</span>
                        <span class="timeline-expand-btn" onclick="toggleTimelineExpanded()" title="Expand to full screen">
                            <i class="fas fa-expand" id="timeline-expand-icon"></i>
                        </span>
                    </div>
                </div>
                <div class="card-body">
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <button class="btn btn-outline-primary w-100" onclick="generatePeriodsFromDocuments()">
                                <i class="fas fa-file-alt"></i> Auto-generate from document dates
                            </button>
                            <small class="text-muted d-block">
                                Creates artifact markers for each document's publication year
                                {% if document_count %}
                                <br>
                                <span class="badge bg-{{ 'success' if docs_with_pub_dates > 0 else 'warning' }} mt-1">
                                    {{ docs_with_pub_dates }}/{{ document_count }} with publication dates
                                </span>
                                {% if docs_with_any_dates > docs_with_pub_dates %}
                                <span class="badge bg-info mt-1">
                                    {{ docs_with_any_dates - docs_with_pub_dates }} will use upload dates
                                </span>
                                {% endif %}
                                {% endif %}
                            </small>
                        </div>
                        <div class="col-md-6">
                            <button class="btn btn-outline-success w-100" onclick="showManualPeriodEditor()">
                                <i class="fas fa-edit"></i> Manual Entry
                            </button>
                            <small class="text-muted">Manually specify time periods</small>
                        </div>
                    </div>

                    {% if use_oed_periods and oed_period_data %}
                    <div class="alert alert-info mb-3">
                        <i class="fas fa-book"></i> <strong>OED-Generated Periods</strong>
                        <p class="mb-2">Time periods automatically generated from Oxford English Dictionary historical data.</p>

                        {% if oed_period_data %}
                        <div class="mb-2">
                            <strong>Term Coverage:</strong>
                            <ul class="mb-0">
                            {% for term, data in oed_period_data.items() %}
                                <li><strong>{{ term }}</strong>: {{ data.min_year }}-{{ data.max_year }} ({{ data.quotation_years|length }} quotations)</li>
                            {% endfor %}
                            </ul>
                        </div>
                        {% endif %}
                    </div>
                    {% endif %}

                    {# List View (default) - vertical cards #}
                    <div id="list-view" class="mb-3">
                        <div class="mb-2">
                            <strong><i class="fas fa-calendar-alt"></i> Periods & Events</strong>
                        </div>
                        {% if time_periods|length > 0 or (semantic_events and semantic_events|length > 0) %}
                        <div id="timeline-container" class="d-flex flex-wrap gap-3">
                            {# Build a merged timeline of periods and events #}
                            {% set timeline_items = [] %}

                            {# Add periods to timeline #}
                            {% for period in time_periods %}
                                {% set period_meta = period_metadata.get(period|string, {}) %}
                                {% set period_docs = period_documents.get(period|string, []) %}
                                {% set source_type = period_meta.get('source', 'manual') %}
                                {# Sort order: START=0, ARTIFACT/EVENT=1, END=2 #}
                                {% set boundary_type = period_meta.get('boundary_type', '') %}
                                {% set sort_order = 0 if boundary_type == 'start' else (2 if boundary_type == 'end' else 1) %}
                                {% set _ = timeline_items.append({
                                    'type': 'period',
                                    'year': period,
                                    'sort_key': (period * 10) + sort_order,
                                    'meta': period_meta,
                                    'docs': period_docs,
                                    'source_type': source_type
                                }) %}
                            {% endfor %}

                            {# Add semantic events to timeline #}
                            {% if semantic_events %}
                                {% for event in semantic_events %}
                                    {% set from_period_meta = period_metadata.get(event.from_period|string, {}) %}
                                    {% set event_year = from_period_meta.get('year', from_period_meta.get('start_year', 0)) %}
                                    {# Events sort in the middle (1) like artifacts #}
                                    {% set _ = timeline_items.append({
                                        'type': 'event',
                                        'year': event_year,
                                        'sort_key': (event_year * 10) + 1,
                                        'event': event,
                                        'from_period': event.from_period,
                                        'to_period': event.to_period
                                    }) %}
                                {% endfor %}
                            {% endif %}

                            {# Sort timeline by year #}
                            {% set sorted_timeline = timeline_items|sort(attribute='sort_key') %}

                            {# Display merged timeline #}
                            {% for item in sorted_timeline %}
                                {% if item.type == 'period' %}
                                    {# Period card #}
                                    <div class="period-card {{ item.source_type }}" data-year="{{ item.year }}" data-source="{{ item.source_type }}"
                                         {% if item.meta.get('boundary_type') %}data-boundary="{{ item.meta.get('boundary_type') }}"{% endif %}>
                                        <div class="period-card-header">
                                            <div>
                                                <span class="period-year">{{ item.year }}</span>
                                                {% if item.meta.get('period_name') %}
                                                <div style="font-size: 0.75rem; color: #6c757d; margin-top: 2px;">{{ item.meta.get('period_name') }}</div>
                                                {% endif %}
                                            </div>
                                            {% if item.meta.get('boundary_type') %}
                                            <span class="period-source-badge manual">
                                                {% if item.meta.get('boundary_type') == 'start' %}START{% else %}END{% endif %}
                                            </span>
                                            {% else %}
                                            <span class="period-source-badge {{ item.source_type }}">
                                                {% if item.source_type == 'auto-generated' %}ARTIFACT{% else %}{{ item.source_type|upper }}{% endif %}
                                            </span>
                                            {% endif %}
                                        </div>

                                        {% if item.docs|length > 0 %}
                                        <div class="period-documents">
                                            <div class="period-documents-title">
                                                <i class="fas fa-file-alt"></i> {{ item.docs|length }} Document{{ 's' if item.docs|length != 1 else '' }}
                                            </div>
                                            {% for doc in item.docs %}
                                            <div class="period-document-item">
                                                <i class="fas fa-circle"></i>
                                                <a href="{{ url_for('text_input.document_detail', document_uuid=doc.uuid) }}" class="period-document-link">{{ doc.title }}</a>
                                            </div>
                                            {% endfor %}
                                        </div>
                                        {% endif %}

                                        <div class="period-card-footer">
                                            <button class="period-remove" onclick="removePeriod({{ item.year }})" title="Remove period">
                                                <i class="fas fa-trash"></i> Remove
                                            </button>
                                        </div>
                                    </div>
                                {% else %}
                                    {# Semantic event card #}
                                    <div class="semantic-event-card {{ item.event.event_type }}" data-event-id="{{ item.event.id }}">
                                        <div class="semantic-event-header">
                                            <div class="semantic-event-type">
                                                <span class="semantic-event-type-label">Event Type</span>
                                                <span class="semantic-event-type-name">
                                                    {{ item.event.type_label if item.event.type_label else item.event.event_type|replace('_', ' ')|title }}
                                                </span>
                                            </div>
                                            <div class="semantic-event-date-range">
                                                {{ item.event.from_period }}{% if item.event.to_period %} → {{ item.event.to_period }}{% endif %}
                                            </div>
                                        </div>

                                        <div class="semantic-event-body">
                                            {% if item.event.citation %}
                                            <div class="small mb-2" style="color: #6c757d; font-style: italic;">
                                                <i class="bi bi-book"></i> {{ item.event.citation }}
                                            </div>
                                            {% endif %}

                                            <div class="semantic-event-description">
                                                {{ item.event.description }}
                                            </div>

                                            {% if item.event.related_documents and item.event.related_documents|length > 0 %}
                                            <div class="semantic-event-related-docs">
                                                <div class="semantic-event-related-docs-title">
                                                    <i class="fas fa-file-alt"></i> Evidence
                                                </div>
                                                {% for doc in item.event.related_documents %}
                                                <div class="semantic-event-doc-item">
                                                    <i class="fas fa-circle"></i>
                                                    <a href="{{ url_for('text_input.document_detail', document_uuid=doc.uuid) }}" class="period-document-link">{{ doc.title }}</a>
                                                </div>
                                                {% endfor %}
                                            </div>
                                            {% endif %}
                                        </div>

                                        <div class="semantic-event-footer">
                                            <button class="semantic-event-edit" onclick="editSemanticEvent('{{ item.event.id }}')" title="Edit event">
                                                <i class="fas fa-edit"></i> Edit
                                            </button>
                                            <button class="semantic-event-remove" onclick="removeSemanticEvent('{{ item.event.id }}')" title="Remove event">
                                                <i class="fas fa-trash"></i> Remove
                                            </button>
                                        </div>
                                    </div>
                                {% endif %}
                            {% endfor %}

                            {# Add buttons #}
                            <button class="period-add-btn" onclick="showAddPeriodDialog()" title="Add period manually">
                                <i class="fas fa-plus"></i>
                                Add Period
                            </button>

                            <button class="semantic-event-add-btn" onclick="showAddSemanticEventDialog()" title="Add semantic event">
                                <i class="fas fa-plus-circle"></i>
                                Add Event
                            </button>
                        </div>
                        {% else %}
                        <div id="timeline-container" class="alert alert-info mb-0">
                            <i class="fas fa-info-circle"></i>
                            <strong>No timeline items yet.</strong>
                            <p class="mb-0 mt-2">Use <strong>Auto-generate from document dates</strong> to create periods, or <strong>Manual Entry</strong> to add periods and events manually.</p>
                        </div>
                        {% endif %}
                    </div>
                    {# End of List View #}
                </div>
            </div>
        </div>
    </div>

    <!-- Term Cards -->
    <div id="terms-container">
        {% for term in terms %}
        {% set term_period_list = term_periods.get(term, time_periods) if term_periods else time_periods %}
        <div class="term-card" data-term="{{ term }}">
            <div class="term-header">
                <div class="term-title">
                    <i class="fas fa-tag text-primary"></i> {{ term }}
                </div>
                <div class="term-actions">
                    <button class="btn btn-sm btn-outline-primary" onclick="fetchTemporalData('{{ term }}')">
                        <i class="fas fa-sync"></i> Fetch Historical Data
                    </button>
                    <button class="btn btn-sm btn-outline-success" onclick="fetchTemporalData('{{ term }}', true)" title="Fetch OED data and suggest time periods">
                        <i class="fas fa-book"></i> Use OED Periods
                    </button>
                    <button class="btn btn-sm btn-outline-info" onclick="analyzeEvolution('{{ term }}')">
                        <i class="fas fa-chart-line"></i> Analyze Evolution
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" onclick="editTerm('{{ term }}')">
                        <i class="fas fa-edit"></i> Edit
                    </button>
                    <button class="btn btn-sm btn-outline-danger" onclick="removeTerm('{{ term }}')">
                        <i class="fas fa-trash"></i> Remove
                    </button>
                </div>
            </div>
            
            <div class="timeline-container">
                {% for period in term_period_list %}
                <div class="time-period-column" data-period="{{ period }}">
                    <div class="period-label">
                        <i class="fas fa-calendar"></i>
                        <span class="period-year">{{ period }}</span>
                    </div>
                    
                    <div class="definition-content" id="def-{{ term }}-{{ period }}">
                        <div class="definition-placeholder">
                            Click "Fetch Historical Data" to load definitions from this period
                        </div>
                    </div>
                    
                    <!-- Frequency Indicator -->
                    <div class="frequency-indicator" id="freq-{{ term }}-{{ period }}" style="display: none;">
                        <small class="text-muted">Term Frequency:</small>
                        <div class="frequency-bar" style="width: 0%"></div>
                        <small class="frequency-value">0 occurrences</small>
                    </div>
                    
                    <!-- Context Changes -->
                    <div class="context-changes">
                        <small class="text-muted">Context & Usage:</small>
                        <div class="context-badges" id="context-{{ term }}-{{ period }}">
                            <!-- Context badges will be loaded here -->
                        </div>
                    </div>
                    
                    {% if not loop.last %}
                    <span class="timeline-arrow">→</span>
                    {% endif %}
                </div>
                {% endfor %}
            </div>
        </div>
        {% endfor %}
    </div>
</div>

<!-- Manual Period Entry Modal -->
<div class="modal fade" id="manualPeriodModal" tabindex="-1" aria-labelledby="manualPeriodModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="manualPeriodModalLabel">Manual Period Entry</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="useRangeMode" onchange="togglePeriodEntryMode()">
                        <label class="form-check-label" for="useRangeMode">
                            Generate from range (start year → end year with intervals)
                        </label>
                    </div>
                </div>

                <!-- Manual List Mode (default) -->
                <div id="manualListMode">
                    <div class="mb-3">
                        <label for="periodsInput" class="form-label">Time Periods (comma-separated years)</label>
                        <input type="text" class="form-control" id="periodsInput"
                               placeholder="e.g., 1910, 1956, 1995, 2019">
                        <small class="text-muted">Enter years separated by commas</small>
                    </div>
                </div>

                <!-- Range Mode (hidden by default) -->
                <div id="rangeMode" style="display: none;">
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label for="startYear" class="form-label">Start Year</label>
                            <input type="number" class="form-control" id="startYear"
                                   placeholder="1900" value="">
                            <small class="text-muted">First document year or 1900</small>
                        </div>
                        <div class="col-md-6 mb-3">
                            <label for="endYear" class="form-label">End Year</label>
                            <input type="number" class="form-control" id="endYear"
                                   placeholder="2025" value="">
                            <small class="text-muted">Current year by default</small>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label for="periodInterval" class="form-label">Period Interval (years)</label>
                        <input type="number" class="form-control" id="periodInterval"
                               value="5" min="1">
                        <small class="text-muted">Years between each period</small>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="applyManualPeriods()">Apply</button>
            </div>
        </div>
    </div>
</div>

<!-- Add Period Modal -->
<div class="modal fade" id="addPeriodModal" tabindex="-1" aria-labelledby="addPeriodModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="addPeriodModalLabel">Add Temporal Period</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label for="periodName" class="form-label">Period Name</label>
                    <input type="text" class="form-control" id="periodName"
                           placeholder="e.g., Early AI Era, Classical Period">
                    <small class="text-muted">Optional: Give this period a descriptive name</small>
                </div>
                <div class="row">
                    <div class="col-md-6 mb-3">
                        <label for="periodStartYear" class="form-label">Start Year <span class="text-danger">*</span></label>
                        <input type="number" class="form-control" id="periodStartYear"
                               placeholder="e.g., 1950" required>
                        <small class="text-muted">Beginning of period</small>
                    </div>
                    <div class="col-md-6 mb-3">
                        <label for="periodEndYear" class="form-label">End Year <span class="text-danger">*</span></label>
                        <input type="number" class="form-control" id="periodEndYear"
                               placeholder="e.g., 1970" required>
                        <small class="text-muted">End of period</small>
                    </div>
                </div>
                <div class="mb-3">
                    <label for="periodDescription" class="form-label">Description</label>
                    <textarea class="form-control" id="periodDescription" rows="2"
                              placeholder="Optional description of what defines this period..."></textarea>
                    <small class="text-muted">Optional: Describe the historical context</small>
                </div>
                <div class="alert alert-info mb-0" style="font-size: 0.875rem;">
                    <i class="fas fa-info-circle"></i> <strong>Note:</strong> Period boundaries can share years with document artifacts. If a year matches an existing document date, the artifact will be converted to a period boundary marker while preserving the document references.
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="savePeriod()">Add Period</button>
            </div>
        </div>
    </div>
</div>

<!-- Semantic Event Modal -->
<div class="modal fade" id="semanticEventModal" tabindex="-1" aria-labelledby="semanticEventModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="semanticEventModalLabel">Add Semantic Event</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="eventEditId" value="">

                <div class="mb-3">
                    <label for="eventType" class="form-label">
                        Event Type <span class="text-danger">*</span>
                        <span class="badge bg-success ms-2" title="Event types from validated ontology"><i class="bi bi-shield-check"></i></span>
                    </label>
                    <select class="form-control" id="eventType" required onchange="showEventTypeMetadata(this)">
                        <option value="">Loading from ontology...</option>
                    </select>
                    <small class="text-muted">Type of semantic transition or event</small>

                    <!-- Metadata display area -->
                    <div id="event-type-metadata" class="mt-2"></div>
                </div>

                <div class="row">
                    <div class="col-md-6 mb-3">
                        <label for="eventFromPeriod" class="form-label">From Period <span class="text-danger">*</span></label>
                        <input type="number" class="form-control" id="eventFromPeriod"
                               placeholder="e.g., 1910" required>
                        <small class="text-muted">Start year of event</small>
                    </div>
                    <div class="col-md-6 mb-3">
                        <label for="eventToPeriod" class="form-label">To Period</label>
                        <input type="number" class="form-control" id="eventToPeriod"
                               placeholder="e.g., 1950 (optional)">
                        <small class="text-muted">End year (leave blank for point event)</small>
                    </div>
                </div>

                <div class="mb-3">
                    <label for="eventDescription" class="form-label">Description <span class="text-danger">*</span></label>
                    <textarea class="form-control" id="eventDescription" rows="4"
                              placeholder="Describe the semantic event, transition, or shift..."
                              required></textarea>
                    <small class="text-muted">What changed? Why is this event significant?</small>
                </div>

                <div class="mb-3">
                    <label for="eventDocuments" class="form-label">Related Documents (Evidence)</label>
                    <select class="form-control" id="eventDocuments" multiple size="5">
                        <!-- Will be populated dynamically with experiment documents -->
                    </select>
                    <small class="text-muted">Select documents that provide evidence for this event</small>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="saveSemanticEvent()">Save Event</button>
            </div>
        </div>
    </div>
</div>

<script>
// Global variables
let experimentId = {{ experiment.id }};
let currentTerms = {{ terms|tojson|safe }};
let timePeriods = {{ time_periods|tojson|safe }};
{% if term_periods %}
let termPeriods = {{ term_periods|tojson|safe }};  // Term-specific periods from OED
{% else %}
let termPeriods = {};  // Term-specific periods from OED
{% endif %}
let termData = {};
let periodDocuments = {{ period_documents|tojson|safe }};  // Documents linked to each period
let periodMetadata = {{ period_metadata|tojson|safe }};    // Metadata about each period

// Semantic events
let semanticEvents = {{ semantic_events|default([])|tojson|safe }};  // Semantic transition events
let experimentDocuments = [];  // Will be populated for document selection

// Toggle timeline expanded view
function toggleTimelineExpanded() {
    const section = document.getElementById('timeline-section');
    const icon = document.getElementById('timeline-expand-icon');

    if (section.classList.contains('timeline-expanded')) {
        // Collapse
        section.classList.remove('timeline-expanded');
        icon.classList.remove('fa-compress');
        icon.classList.add('fa-expand');
        document.body.style.overflow = '';
    } else {
        // Expand
        section.classList.add('timeline-expanded');
        icon.classList.remove('fa-expand');
        icon.classList.add('fa-compress');
        document.body.style.overflow = 'hidden';
    }
}

// Close expanded view on ESC key
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        const section = document.getElementById('timeline-section');
        if (section && section.classList.contains('timeline-expanded')) {
            toggleTimelineExpanded();
        }
    }
});

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    // Load any saved temporal data
    loadSavedTemporalData();

    // Fetch experiment documents for event modal
    fetchExperimentDocuments();

    // Load event types from ontology
    loadEventTypes();
});

// Load event types from ontology
async function loadEventTypes() {
    try {
        const response = await fetch(`/experiments/${experimentId}/semantic_event_types`);
        const data = await response.json();

        if (!data.success) {
            console.error('Failed to load event types:', data.error);
            return;
        }

        console.log(`Loaded ${data.count} event types from ${data.source}`);

        // Populate dropdown
        const select = document.getElementById('eventType');
        select.innerHTML = '<option value="">-- Select semantic change type --</option>';

        data.event_types.forEach(type => {
            const option = document.createElement('option');
            option.value = type.value;
            option.textContent = type.label;

            // Store metadata as data attributes
            option.dataset.definition = type.definition || '';
            option.dataset.citation = type.citation || '';
            option.dataset.example = type.example || '';
            option.dataset.uri = type.uri || '';

            select.appendChild(option);
        });

    } catch (error) {
        console.error('Error loading event types:', error);
        // Keep fallback "Loading..." option
    }
}

// Show event type metadata when user selects an event type
function showEventTypeMetadata(selectElement) {
    const selectedOption = selectElement.options[selectElement.selectedIndex];

    if (!selectedOption || !selectedOption.value) {
        document.getElementById('event-type-metadata').innerHTML = '';
        return;
    }

    const definition = selectedOption.dataset.definition;
    const citation = selectedOption.dataset.citation;
    const example = selectedOption.dataset.example;

    let html = `
        <div class="alert alert-info">
            <strong>Definition:</strong> ${definition}
    `;

    if (citation) {
        html += `<br><small><strong>Citation:</strong> ${citation}</small>`;
    }

    if (example) {
        html += `<br><small><strong>Example:</strong> ${example}</small>`;
    }

    html += '</div>';

    document.getElementById('event-type-metadata').innerHTML = html;
}

// Remove term
function removeTerm(term) {
    if (!confirm(`Are you sure you want to remove the term "${term}"?`)) {
        return;
    }
    
    // Remove from array
    currentTerms = currentTerms.filter(t => t !== term);
    
    // Remove card
    const card = document.querySelector(`.term-card[data-term="${term}"]`);
    if (card) {
        card.remove();
    }
    
    // Update count
    document.getElementById('term-count').textContent = currentTerms.length;
    
    // Save to backend
    saveTerms();
}

// Edit term
function editTerm(oldTerm) {
    const newTerm = prompt(`Edit term:`, oldTerm);
    if (!newTerm || newTerm === oldTerm) {
        return;
    }
    
    if (currentTerms.includes(newTerm)) {
        alert('This term already exists');
        return;
    }
    
    // Update in array
    const index = currentTerms.indexOf(oldTerm);
    currentTerms[index] = newTerm;
    
    // Update card
    const card = document.querySelector(`.term-card[data-term="${oldTerm}"]`);
    if (card) {
        card.dataset.term = newTerm;
        card.querySelector('.term-title').innerHTML = `<i class="fas fa-tag text-primary"></i> ${newTerm}`;
        
        // Update all IDs
        card.querySelectorAll('[id*="' + oldTerm + '"]').forEach(elem => {
            elem.id = elem.id.replace(oldTerm, newTerm);
        });
    }
    
    // Save to backend
    saveTerms();
}

// Fetch temporal data for a term
async function fetchTemporalData(term, useOED = false) {
    const card = document.querySelector(`.term-card[data-term="${term}"]`);
    const button = useOED ? card.querySelector('.btn-outline-success') : card.querySelector('.btn-outline-primary');
    
    // Show loading state
    const originalHTML = button.innerHTML;
    button.innerHTML = '<span class="loading-spinner"></span> Fetching...';
    button.disabled = true;
    
    try {
        const response = await fetch(`/experiments/${experimentId}/fetch_temporal_data`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                term: term,
                periods: timePeriods,
                use_oed: useOED
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            // If OED data is available, offer to update periods
            if (data.oed_data) {
                const oedData = data.oed_data;
                const message = `OED data found for "${term}":\n` +
                    `Date range: ${oedData.min_year} - ${oedData.max_year}\n` +
                    `Suggested periods: ${oedData.suggested_periods.join(', ')}\n\n` +
                    `Would you like to update the time periods based on OED data?`;
                
                if (confirm(message)) {
                    // Update time periods globally
                    timePeriods = oedData.suggested_periods;
                    
                    // Refresh the UI with new periods
                    await refreshTimePeriodsUI();
                    
                    // Re-fetch data with new periods
                    await fetchTemporalData(term, false);
                    return;
                }
            } else if (useOED) {
                // OED was requested but no data found
                alert(`No OED historical data found for "${term}".\n\nThis could be because:\n- The term is not in the OED database\n- OED API credentials are not configured\n- The term needs a different spelling or form\n\nUsing default time periods instead.`);
            }
            
            // Update definitions and frequency data
            displayTemporalData(term, data.temporal_data);
            
            // Show frequency indicators if enabled
            if (data.frequency_data) {
                displayFrequencyData(term, data.frequency_data);
            }
            
            // Update periods if they changed
            if (data.periods_used && data.periods_used.length > 0) {
                timePeriods = data.periods_used;
            }
        } else {
            alert('Error fetching temporal data: ' + data.error);
        }
    } catch (error) {
        alert('Error fetching temporal data: ' + error.message);
    } finally {
        button.innerHTML = originalHTML;
        button.disabled = false;
    }
}

// Display temporal data
function displayTemporalData(term, temporalData) {
    timePeriods.forEach(period => {
        const contentDiv = document.getElementById(`def-${term}-${period}`);
        
        if (contentDiv) {
            const data = temporalData[period];
            if (data) {
                contentDiv.innerHTML = `
                    <div class="definition-text">${data.definition || 'No definition found for this period'}</div>
                    ${data.source ? `<div class="definition-source">Source: ${data.source}</div>` : ''}
                    ${data.evolution ? `<span class="evolution-indicator evolution-${data.evolution}">${data.evolution}</span>` : ''}
                `;
                
                // Add context badges
                const contextDiv = document.getElementById(`context-${term}-${period}`);
                if (contextDiv && data.contexts) {
                    let badges = '';
                    data.contexts.forEach(context => {
                        badges += `<span class="context-badge">${context}</span>`;
                    });
                    contextDiv.innerHTML = badges || '<span class="text-muted">No context data</span>';
                }
            } else {
                contentDiv.innerHTML = `
                    <div class="definition-placeholder">No data available for this period</div>
                `;
            }
        }
    });
}

// Display frequency data
function displayFrequencyData(term, frequencyData) {
    const maxFreq = Math.max(...Object.values(frequencyData));
    
    timePeriods.forEach(period => {
        const freqDiv = document.getElementById(`freq-${term}-${period}`);
        
        if (freqDiv && frequencyData[period] !== undefined) {
            const freq = frequencyData[period];
            const percentage = maxFreq > 0 ? (freq / maxFreq) * 100 : 0;
            
            freqDiv.style.display = 'block';
            freqDiv.querySelector('.frequency-bar').style.width = percentage + '%';
            freqDiv.querySelector('.frequency-value').textContent = `${freq} occurrences`;
        }
    });
}

// Analyze evolution of a term
async function analyzeEvolution(term) {
    try {
        const response = await fetch(`/experiments/${experimentId}/analyze_evolution`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                term: term,
                periods: timePeriods
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Display evolution analysis
            alert(`Evolution Analysis for "${term}":\n\n${data.analysis}`);
        } else {
            alert('Error analyzing evolution: ' + data.error);
        }
    } catch (error) {
        alert('Error analyzing evolution: ' + error.message);
    }
}

// Generate periods from documents
async function generatePeriodsFromDocuments() {
    if (!confirm('Generate time periods from document dates?\n\nThis will create one period for each unique publication year in your documents.')) {
        return;
    }

    try {
        const response = await fetch(`/experiments/${experimentId}/generate_periods_from_documents`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        });

        const data = await response.json();

        if (data.success) {
            // Update periods
            timePeriods = data.periods;

            // Reload page to get updated period_documents and period_metadata
            location.reload();
        } else {
            alert('Error generating periods: ' + data.error);
        }
    } catch (error) {
        alert('Error generating periods: ' + error.message);
    }
}

// Show manual period editor
function showManualPeriodEditor() {
    // Populate current periods
    document.getElementById('periodsInput').value = timePeriods.join(', ');

    // Set smart defaults for range mode
    const startDefault = timePeriods.length > 0 ? Math.min(...timePeriods) : 1900;
    const endDefault = new Date().getFullYear();

    document.getElementById('startYear').value = startDefault;
    document.getElementById('endYear').value = endDefault;

    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('manualPeriodModal'));
    modal.show();
}

// Toggle between manual list and range mode
function togglePeriodEntryMode() {
    const useRange = document.getElementById('useRangeMode').checked;
    document.getElementById('manualListMode').style.display = useRange ? 'none' : 'block';
    document.getElementById('rangeMode').style.display = useRange ? 'block' : 'none';
}

// Apply manual periods
function applyManualPeriods() {
    const useRange = document.getElementById('useRangeMode').checked;
    let newPeriods = [];

    if (useRange) {
        // Range mode: generate periods from start to end with interval
        const startYear = parseInt(document.getElementById('startYear').value);
        const endYear = parseInt(document.getElementById('endYear').value);
        const interval = parseInt(document.getElementById('periodInterval').value);

        if (isNaN(startYear) || isNaN(endYear) || isNaN(interval)) {
            alert('Please enter valid numbers for start year, end year, and interval');
            return;
        }

        if (startYear >= endYear) {
            alert('Start year must be less than end year');
            return;
        }

        if (interval < 1) {
            alert('Interval must be at least 1 year');
            return;
        }

        // Generate periods
        let current = startYear;
        while (current <= endYear) {
            newPeriods.push(current);
            current += interval;
        }

        // Ensure end year is included if not already
        if (newPeriods[newPeriods.length - 1] < endYear) {
            newPeriods.push(endYear);
        }
    } else {
        // Manual list mode
        const periodsStr = document.getElementById('periodsInput').value;

        if (!periodsStr.trim()) {
            alert('Please enter at least one period');
            return;
        }

        newPeriods = periodsStr.split(',')
            .map(p => parseInt(p.trim()))
            .filter(p => !isNaN(p))
            .sort((a, b) => a - b);

        if (newPeriods.length === 0) {
            alert('No valid periods entered');
            return;
        }
    }

    // Update periods
    timePeriods = newPeriods;

    // Close modal
    const modal = bootstrap.Modal.getInstance(document.getElementById('manualPeriodModal'));
    modal.hide();

    // Refresh UI
    refreshTimePeriodsUI();
}

// Show add period dialog
function showAddPeriodDialog() {
    // Reset form
    document.getElementById('periodName').value = '';
    document.getElementById('periodStartYear').value = '';
    document.getElementById('periodEndYear').value = '';
    document.getElementById('periodDescription').value = '';

    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('addPeriodModal'));
    modal.show();
}

// Save period (creates two boundary markers)
async function savePeriod() {
    const name = document.getElementById('periodName').value.trim();
    const startYear = parseInt(document.getElementById('periodStartYear').value);
    const endYear = parseInt(document.getElementById('periodEndYear').value);
    const description = document.getElementById('periodDescription').value.trim();

    // Validation
    if (isNaN(startYear) || isNaN(endYear)) {
        alert('Please enter valid start and end years');
        return;
    }

    if (startYear >= endYear) {
        alert('Start year must be before end year');
        return;
    }

    // Check if years already exist as PERIOD BOUNDARIES (not artifacts)
    const startMeta = periodMetadata[startYear.toString()] || {};
    const endMeta = periodMetadata[endYear.toString()] || {};

    if (startMeta.boundary_type) {
        alert(`Year ${startYear} is already a ${startMeta.boundary_type} boundary for period "${startMeta.period_name || 'Unnamed'}"`);
        return;
    }

    if (endMeta.boundary_type) {
        alert(`Year ${endYear} is already a ${endMeta.boundary_type} boundary for period "${endMeta.period_name || 'Unnamed'}"`);
        return;
    }

    // Generate unique period ID
    const periodId = `period_${Date.now()}`;

    // Add years to timePeriods if they don't already exist
    if (!timePeriods.includes(startYear)) {
        timePeriods.push(startYear);
    }
    if (!timePeriods.includes(endYear)) {
        timePeriods.push(endYear);
    }
    timePeriods.sort((a, b) => a - b);

    // Preserve existing documents if year was an artifact
    const existingStartDocs = periodDocuments[startYear.toString()] || [];
    const existingEndDocs = periodDocuments[endYear.toString()] || [];

    // Add/update metadata for start boundary
    periodMetadata[startYear.toString()] = {
        source: 'manual',
        document_count: existingStartDocs.length,
        boundary_type: 'start',
        period_id: periodId,
        period_name: name,
        period_description: description,
        paired_with: endYear
    };
    periodDocuments[startYear.toString()] = existingStartDocs;

    // Add/update metadata for end boundary
    periodMetadata[endYear.toString()] = {
        source: 'manual',
        document_count: existingEndDocs.length,
        boundary_type: 'end',
        period_id: periodId,
        period_name: name,
        period_description: description,
        paired_with: startYear
    };
    periodDocuments[endYear.toString()] = existingEndDocs;

    // Close modal
    const modal = bootstrap.Modal.getInstance(document.getElementById('addPeriodModal'));
    modal.hide();

    // Save to backend
    await saveTerms(() => {
        // Refresh UI after save completes
        refreshTimePeriodsUI();
    });
}

// Remove a period
async function removePeriod(year) {
    const yearStr = year.toString();
    const meta = periodMetadata[yearStr] || {};

    // Check if this is a period boundary (has a paired year)
    if (meta.paired_with) {
        const periodName = meta.period_name || `Period ${year}-${meta.paired_with}`;
        if (!confirm(`Remove entire period "${periodName}"?\n\nThis will remove both boundary markers: ${Math.min(year, meta.paired_with)} and ${Math.max(year, meta.paired_with)}`)) {
            return;
        }

        // Remove both boundaries
        timePeriods = timePeriods.filter(p => p !== year && p !== meta.paired_with);
        delete periodMetadata[yearStr];
        delete periodMetadata[meta.paired_with.toString()];
        delete periodDocuments[yearStr];
        delete periodDocuments[meta.paired_with.toString()];
    } else {
        // Single date marker
        if (!confirm(`Remove date marker ${year}?`)) {
            return;
        }

        timePeriods = timePeriods.filter(p => p !== year);
        delete periodMetadata[yearStr];
        delete periodDocuments[yearStr];
    }

    // Save to backend
    await saveTerms(() => {
        // Refresh UI after save completes
        refreshTimePeriodsUI();
    });
}

// Refresh the periods UI
// Unified timeline refresh (periods + semantic events)
function refreshTimelineUI() {
    const container = document.getElementById('timeline-container');
    container.innerHTML = '';

    // Build merged timeline
    const timelineItems = [];

    // Add periods
    timePeriods.forEach(period => {
        const meta = periodMetadata[period.toString()] || {};
        const boundaryType = meta.boundary_type;
        // Sort order: START=0, ARTIFACT/EVENT=1, END=2
        const sortOrder = boundaryType === 'start' ? 0 : (boundaryType === 'end' ? 2 : 1);

        timelineItems.push({
            type: 'period',
            year: period,
            sortKey: (period * 10) + sortOrder,
            data: {
                period: period,
                meta: meta,
                docs: periodDocuments[period.toString()] || [],
                sourceType: meta.source || 'manual'
            }
        });
    });

    // Add semantic events
    semanticEvents.forEach(event => {
        // Events sort in the middle (1) like artifacts
        timelineItems.push({
            type: 'event',
            year: event.from_period,
            sortKey: (event.from_period * 10) + 1,
            data: event
        });
    });

    // Sort by year
    timelineItems.sort((a, b) => a.sortKey - b.sortKey);

    if (timelineItems.length === 0) {
        container.className = 'alert alert-info mb-0';
        container.innerHTML = `
            <i class="fas fa-info-circle"></i>
            <strong>No timeline items yet.</strong>
            <p class="mb-0 mt-2">Use <strong>Auto-generate from document dates</strong> to create periods, or <strong>Manual Entry</strong> to add periods and events manually.</p>
        `;
    } else {
        container.className = 'd-flex flex-wrap gap-3';

        // Render timeline items
        timelineItems.forEach(item => {
            if (item.type === 'period') {
                const { period, meta, docs, sourceType } = item.data;
                const card = document.createElement('div');
                card.className = `period-card ${sourceType}`;
                card.setAttribute('data-year', period);
                card.setAttribute('data-source', sourceType);
                if (meta.boundary_type) {
                    card.setAttribute('data-boundary', meta.boundary_type);
                }

                const boundaryType = meta.boundary_type;
                const periodName = meta.period_name;
                const badgeText = boundaryType ? (boundaryType === 'start' ? 'START' : 'END') :
                                (sourceType === 'auto-generated' ? 'ARTIFACT' : sourceType.toUpperCase());
                const badgeClass = boundaryType ? 'manual' : sourceType;

                let cardHTML = `
                    <div class="period-card-header">
                        <div>
                            <span class="period-year">${period}</span>
                            ${periodName ? `<div style="font-size: 0.75rem; color: #6c757d; margin-top: 2px;">${periodName}</div>` : ''}
                        </div>
                        <span class="period-source-badge ${badgeClass}">${badgeText}</span>
                    </div>
                `;

                if (docs.length > 0) {
                    cardHTML += `
                        <div class="period-documents">
                            <div class="period-documents-title">
                                <i class="fas fa-file-alt"></i> ${docs.length} Document${docs.length !== 1 ? 's' : ''}
                            </div>
                            ${docs.map(doc => `
                                <div class="period-document-item">
                                    <i class="fas fa-circle"></i>
                                    <a href="/document/${doc.uuid}" class="period-document-link">${doc.title}</a>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                cardHTML += `
                    <div class="period-card-footer">
                        <button class="period-remove" onclick="removePeriod(${period})" title="Remove period">
                            <i class="fas fa-trash"></i> Remove
                        </button>
                    </div>
                `;

                card.innerHTML = cardHTML;
                container.appendChild(card);
            } else {
                // Semantic event
                const event = item.data;
                const card = document.createElement('div');
                card.className = `semantic-event-card ${event.event_type}`;
                card.setAttribute('data-event-id', event.id);

                const eventTypeName = event.type_label || event.event_type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                const dateRange = event.to_period ? `${event.from_period} → ${event.to_period}` : `${event.from_period}`;

                let cardHTML = `
                    <div class="semantic-event-header">
                        <div class="semantic-event-type">
                            <span class="semantic-event-type-label">Event Type</span>
                            <span class="semantic-event-type-name">${eventTypeName}</span>
                        </div>
                        <div class="semantic-event-date-range">${dateRange}</div>
                    </div>
                    <div class="semantic-event-body">
                `;

                if (event.citation) {
                    cardHTML += `
                        <div class="small mb-2" style="color: #6c757d; font-style: italic;">
                            <i class="bi bi-book"></i> ${event.citation}
                        </div>
                    `;
                }

                cardHTML += `
                        <div class="semantic-event-description">${event.description}</div>
                `;

                if (event.related_documents && event.related_documents.length > 0) {
                    cardHTML += `
                        <div class="semantic-event-related-docs">
                            <div class="semantic-event-related-docs-title">
                                <i class="fas fa-file-alt"></i> Evidence
                            </div>
                            ${event.related_documents.map(doc => `
                                <div class="semantic-event-doc-item">
                                    <i class="fas fa-circle"></i>
                                    <a href="/document/${doc.uuid}" class="period-document-link">${doc.title}</a>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                cardHTML += `
                    </div>
                    <div class="semantic-event-footer">
                        <button class="semantic-event-edit" onclick="editSemanticEvent('${event.id}')" title="Edit event">
                            <i class="fas fa-edit"></i> Edit
                        </button>
                        <button class="semantic-event-remove" onclick="removeSemanticEvent('${event.id}')" title="Remove event">
                            <i class="fas fa-trash"></i> Remove
                        </button>
                    </div>
                `;

                card.innerHTML = cardHTML;
                container.appendChild(card);
            }
        });

        // Add buttons
        const addPeriodBtn = document.createElement('button');
        addPeriodBtn.className = 'period-add-btn';
        addPeriodBtn.onclick = showAddPeriodDialog;
        addPeriodBtn.title = 'Add period manually';
        addPeriodBtn.innerHTML = `<i class="fas fa-plus"></i> Add Period`;
        container.appendChild(addPeriodBtn);

        const addEventBtn = document.createElement('button');
        addEventBtn.className = 'semantic-event-add-btn';
        addEventBtn.onclick = showAddSemanticEventDialog;
        addEventBtn.title = 'Add semantic event';
        addEventBtn.innerHTML = `<i class="fas fa-plus-circle"></i> Add Event`;
        container.appendChild(addEventBtn);
    }
}

// Alias for backwards compatibility
function refreshTimePeriodsUI() {
    refreshTimelineUI();
}

// Save terms to backend
async function saveTerms(callback) {
    try {
        const response = await fetch(`/experiments/${experimentId}/update_temporal_terms`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                terms: currentTerms,
                periods: timePeriods,
                temporal_data: {
                    ...termData,
                    period_metadata: periodMetadata,
                    period_documents: periodDocuments
                }
            })
        });

        const data = await response.json();

        if (data.success) {
            if (callback) callback();
        } else {
            alert('Error saving terms: ' + data.error);
        }
    } catch (error) {
        alert('Error saving terms: ' + error.message);
    }
}

// Load saved temporal data
async function loadSavedTemporalData() {
    try {
        const response = await fetch(`/experiments/${experimentId}/get_temporal_terms`);
        const data = await response.json();
        
        if (data.success && data.temporal_data) {
            termData = data.temporal_data;
            
            // Display any saved data
            Object.keys(termData).forEach(term => {
                if (termData[term]) {
                    displayTemporalData(term, termData[term]);
                }
            });
        }
    } catch (error) {
        console.error('Error loading saved temporal data:', error);
    }
}

// ========== Semantic Events Functions ==========

// Fetch experiment documents for selection dropdown
async function fetchExperimentDocuments() {
    try {
        const response = await fetch(`/experiments/${experimentId}/documents`);
        const data = await response.json();

        if (data.success) {
            experimentDocuments = data.documents;
            populateDocumentSelect();
        }
    } catch (error) {
        console.error('Error fetching experiment documents:', error);
    }
}

// Populate document select dropdown in modal
function populateDocumentSelect() {
    const select = document.getElementById('eventDocuments');
    select.innerHTML = '';

    experimentDocuments.forEach(doc => {
        const option = document.createElement('option');
        option.value = doc.id;
        option.textContent = doc.title || 'Untitled Document';
        select.appendChild(option);
    });
}

// Show add semantic event dialog
function showAddSemanticEventDialog() {
    // Reset form
    document.getElementById('eventEditId').value = '';
    document.getElementById('eventType').value = '';
    document.getElementById('eventFromPeriod').value = '';
    document.getElementById('eventToPeriod').value = '';
    document.getElementById('eventDescription').value = '';
    document.getElementById('eventDocuments').selectedIndex = -1;

    // Update modal title
    document.getElementById('semanticEventModalLabel').textContent = 'Add Semantic Event';

    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('semanticEventModal'));
    modal.show();
}

// Edit semantic event
function editSemanticEvent(eventId) {
    const event = semanticEvents.find(e => e.id === eventId);
    if (!event) return;

    // Populate form
    document.getElementById('eventEditId').value = eventId;
    document.getElementById('eventType').value = event.event_type;
    document.getElementById('eventFromPeriod').value = event.from_period;
    document.getElementById('eventToPeriod').value = event.to_period || '';
    document.getElementById('eventDescription').value = event.description;

    // Select related documents
    const select = document.getElementById('eventDocuments');
    Array.from(select.options).forEach(option => {
        option.selected = event.related_documents?.some(doc => doc.id == option.value) || false;
    });

    // Update modal title
    document.getElementById('semanticEventModalLabel').textContent = 'Edit Semantic Event';

    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('semanticEventModal'));
    modal.show();
}

// Save semantic event
async function saveSemanticEvent() {
    const eventId = document.getElementById('eventEditId').value;
    const eventType = document.getElementById('eventType').value;
    const fromPeriod = document.getElementById('eventFromPeriod').value;
    const toPeriod = document.getElementById('eventToPeriod').value;
    const description = document.getElementById('eventDescription').value;
    const select = document.getElementById('eventDocuments');
    const relatedDocIds = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));

    // Validation
    if (!eventType) {
        alert('Please select an event type');
        return;
    }

    if (!fromPeriod) {
        alert('Please enter a start period');
        return;
    }

    if (!description.trim()) {
        alert('Please enter a description');
        return;
    }

    const eventData = {
        id: eventId || Date.now().toString(),
        event_type: eventType,
        from_period: parseInt(fromPeriod),
        to_period: toPeriod ? parseInt(toPeriod) : null,
        description: description.trim(),
        related_document_ids: relatedDocIds
    };

    try {
        const response = await fetch(`/experiments/${experimentId}/save_semantic_event`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(eventData)
        });

        // Check if response is JSON before parsing
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
            const text = await response.text();
            console.error('Server returned non-JSON response:', text.substring(0, 500));
            alert('Server error: Expected JSON but got ' + contentType + '. Check browser console for details.');
            return;
        }

        const data = await response.json();

        if (data.success) {
            // Update local state
            semanticEvents = data.semantic_events;

            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('semanticEventModal'));
            modal.hide();

            // Refresh UI
            refreshTimelineUI();
        } else {
            alert('Error saving semantic event: ' + data.error);
        }
    } catch (error) {
        console.error('Error saving semantic event:', error);
        alert('Error saving semantic event: ' + error.message);
    }
}

// Remove semantic event
async function removeSemanticEvent(eventId) {
    const event = semanticEvents.find(e => e.id === eventId);
    if (!event) return;

    if (!confirm(`Remove semantic event "${event.event_type.replace('_', ' ')}" from ${event.from_period}?`)) {
        return;
    }

    try {
        const response = await fetch(`/experiments/${experimentId}/remove_semantic_event`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ event_id: eventId })
        });

        const data = await response.json();

        if (data.success) {
            semanticEvents = data.semantic_events;
            refreshTimelineUI();
        } else {
            alert('Error removing semantic event: ' + data.error);
        }
    } catch (error) {
        alert('Error removing semantic event: ' + error.message);
    }
}

</script>
{% endblock %}
